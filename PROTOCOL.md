ACM notification protocol
=========================

The ACM notification protocol is a notification protocol (devired from the
pubsub model), available both on a stream socket or over a REST API.

Current version of the protocol is ``1``.

Terminology
===========

The terminology is largely inherited from the pubsub model.

A **device** is typically a mobile device, a Web browser or any terminal
client that runs **applications**, each talking to its own **application
server**.

For efficient notification handling and lower battery usage, applications
do not maintain constant connection to their application server, but rely
on a the **notification package**, a system component that interacts with
a **notification broker**, which routes notifications.

The device's notification package **subscribes** to various **channels**
on the broker. Application servers can **publish** notification to these
channels, in order to notify the device.

A notification has a **target**, which is the combination of device and
application. The target is materialized by the channel when publishing
the notification.

The **client** is the notification subscriber, usually a mobile device,
the **server** is the application server, while the **broker** routes
notifications in between.

Design principles
=================

The ACM notification protocol was designed for efficiency and security.

From an efficiency point of view:
 - the protocol only provides two operations, subscription and
   publicaiton, unsbscribing, listing channels and other operations are not
   useful for the protocol purpose
 - the protocol uses simple fixed-length structures at the socket level
 - the protocol is available on a stream socket and a polling REST API
 - notifications can carry payloads of limited size

From a security point of view:
 - the channel names do not reveal anything about the notification target,
   type or content
 - the notification payload is encrypted and authenticated

Additionally, the following specificities apply:
 - the broker will handle many channels
 - each channel will be subscribed by very few clients (usually 1)

Objects and operations
======================

Channel
-------

A channel is materialized by a 32 byte (256 bit) identifier. The full space
of 32 byte strings SHOULD be used and channels SHOULD be generated so
that collisions are avoided and identifiers are distributed properly.

Channel identifiers SHOULD be generated by the client.

Channel identifiers SHOULD be generated using cryptographic hash functions or
symmetric cryptography, with a key kept private by the client.

Notification
------------

A notification is a variable length message sent over a channel. Multiple
notification formats can coexist, a notification MUST have a 16 bits format
identifier.

A notification MUST have a payload. The payload length MUST be a multiple
of 16 bytes (128 bits). The payload length MUST NOT exceed 4096 bytes.

Subscribe
---------

When using the socket interface, subscribing to a channel consists in the
client sending the subscribed channel identifier to the server.

The server MUST then try and transmit all new notifications published on
that channel to the client.

Publish
-------

A server can publish a notification to any channel identifier. If a device
has subscribed to the channel, it should be notified, otherwise notifications
SHOULD be queued for a limited time until a device polls the channel.

Poll
----

When using the REST API, a client may poll a list of channels. When polling,
a client MUST provide the list of channels it wishes to poll from.
The server MUST transmit and flush all queued notifications on these
channels.

Socket-based protocol
=====================

The socket-based protocol is intended to be used over a TLS socket or a
HTTPS Websocket. It is only used by the client to communicate with the
broker.

If the socket protocol is exposed over Websocket, it must be available
at `/ws` and use a single message for each operation.

Connection and initialization
-----------------------------

Upon connection, the broker MUST send a 32 bytes message to the client.

    0       4       8      12      16      20      24      28      31
    -----------------------------------------------------------------
    |  ver  |                    reserved                           |
    -----------------------------------------------------------------

 * `ver` is the protocol version number, stored as a little endian number

The client SHOULD terminate the connection if the protocol version is
unsupported.

Subscription
------------

When subscribing to a channel, a client MUST send a 32 bytes message to
the broker.

    0       4       8      12      16      20      24      28      31
    -----------------------------------------------------------------
    |                             id                                |
    -----------------------------------------------------------------

 * `id` is the channel identifier represented as a byte string

Subscription is scoped to the socket life.

Notification
------------

When a new notification is published to a channel, the broker notifies
the client. It MUST send a single message, of variable length.

The message MUST have a 64 bytes header.

    0       4       8      12      16      20      24      28      31
    -----------------------------------------------------------------
    |                             id                                |
    -----------------------------------------------------------------
    |  fmt  |l|                       reserved                      |
    -----------------------------------------------------------------

 * `id` is the channel identifier represented as a byte string
 * `fmt` is the notification format number represented in little endian
 * `len` is the number of 16 bytes blocks in the message, represented as
   a single byte

Finalization
------------

The client or the server MAY either finish or lose the connection at any
time, thus canceling all subscriptions.

A new connection must be established by the client, and all subscription
renewed on the new connection.

REST API
========

The REST API is designed to be exposed over HTTPS, it is the only API
available to the server for publishing.

All replies MUST contain the `X-acm-version` header, with the protocol
version represented as a decimal integer.

Version
-------

The protocol version is exposed over `/` using `HEAD`.

The response code MUST be `200`.

Publish
-------

Publishing a notification is exposed over `/pub` using POST.

The body MUST contain a JSON encoded structure, with the following fields:

* `channel`, the hex-encoded identifier byte string
* `format`, the notification format as an integer
* `content`, the notification content

The response code MUST be `200`.

Poll
----

Polling for notifications is exposed over `/poll` using `GET`.

The query string MUST contain as many parameters named `id` as channels are
polled. Every `id` contains the hex-encoded identifier of a polled channel.

The response code MUST be `200`.

The response body MUST contain a JSON encoded list, with items containing
the following fields:

* `channel`, the hex-encoded identifier byte string
* `format`, the notification format as an integer
* `content`, the notification content


